<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Recording Layout</title>
  <script src="https://unpkg.com/livekit-client/dist/livekit-client.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background: #000000;
      color: white;
      overflow: hidden;
      width: 1920px;
      height: 1080px;
    }

    #main-container {
      display: flex;
      width: 100%;
      height: 100%;
      background: #000000;
    }

    /* Left side - Video Player */
    #video-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: #000000;
      padding: 30px;
      padding-right: 15px;
    }

    #video-player {
      flex: 1;
      background: #2a2a2a;
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
    }

    #video-player video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    #video-placeholder {
      font-size: 28px;
      color: #ffffff;
      font-weight: 500;
    }

    /* Room info footer */
    #room-info {
      background: transparent;
      padding: 0;
    }

    #room-info div {
      font-size: 18px;
      color: #ffffff;
      margin-bottom: 6px;
      line-height: 1.5;
    }

    .info-label {
      color: #ffffff;
    }

    /* Right side - Active Speaker + Participants */
    #right-section {
      width: 400px;
      display: flex;
      flex-direction: column;
      background: #000000;
      padding: 30px;
      padding-left: 15px;
      gap: 20px;
    }

    /* Active Speaker Box */
    #active-speaker-container {
      background: #1e3a5f;
      border-radius: 12px;
      border: 3px solid #4a6b8a;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 180px;
    }

    #active-speaker-title {
      font-size: 20px;
      font-weight: 600;
      color: #ffffff;
      text-align: center;
    }

    #active-speaker-container video {
      display: none;
    }

    /* Participants Section */
    #participants-container {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    #participants-header {
      font-size: 18px;
      font-weight: 600;
      color: #ffffff;
      margin-bottom: 12px;
      text-align: center;
    }

    #participants-grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 10px;
      overflow-y: auto;
      align-content: start;
    }

    /* Custom scrollbar */
    #participants-grid::-webkit-scrollbar {
      width: 6px;
    }

    #participants-grid::-webkit-scrollbar-track {
      background: transparent;
    }

    #participants-grid::-webkit-scrollbar-thumb {
      background: #4a6b8a;
      border-radius: 3px;
    }

    .participant-tile {
      aspect-ratio: 4 / 3;
      background: #2d3f54;
      border-radius: 10px;
      border: 2px solid #4a6b8a;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .participant-tile video {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .participant-tile.empty {
      background: #1e2d3d;
    }

    .participant-name {
      position: absolute;
      bottom: 8px;
      left: 8px;
      background: rgba(0, 0, 0, 0.75);
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      max-width: calc(100% - 16px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      z-index: 10;
      color: #ffffff;
    }
  </style>
</head>
<body>
  <div id="main-container">
    <!-- Left Section: Video Player + Room Info -->
    <div id="video-section">
      <div id="video-player">
        <div id="video-placeholder">Video Player</div>
      </div>
      
      <div id="room-info">
        <div>
          <span class="info-label">Source name: Livestream 1</span>
        </div>
        <div>
          <span class="info-label" id="timestamp"></span>
        </div>
        <div>
          <span class="info-label">Room name: <span id="room-name">Alex's Editing Room</span></span>
        </div>
        <div>
          <span class="info-label" id="room-ids">Room ID - Team ID - Session ID</span>
        </div>
      </div>
    </div>

    <!-- Right Section: Active Speaker + Participant Grid -->
    <div id="right-section">
      <!-- Active Speaker -->
      <div id="active-speaker-container">
        <div id="active-speaker-title">Active Speaker</div>
      </div>

      <!-- Participants Grid -->
      <div id="participants-container">
        <div id="participants-header">Participant videos</div>
        <div id="participants-grid">
          <!-- Empty tiles will be created here -->
        </div>
      </div>
    </div>
  </div>

  <script>
    console.log('Layout template loaded');
    
    const urlParams = new URLSearchParams(window.location.search);
    const url = urlParams.get('url');
    const token = urlParams.get('token');

    console.log('Connection params:', { url: !!url, token: !!token });

    let room;
    let activeSpeakerParticipant = null;
    const participantElements = new Map();
    const MAX_PARTICIPANT_TILES = 14; // 7 rows x 2 columns

    // Initialize empty participant tiles
    function initializeEmptyTiles() {
      const grid = document.getElementById('participants-grid');
      grid.innerHTML = ''; // Clear existing
      
      for (let i = 0; i < MAX_PARTICIPANT_TILES; i++) {
        const tile = document.createElement('div');
        tile.className = 'participant-tile empty';
        tile.id = `tile-${i}`;
        grid.appendChild(tile);
      }
    }

    function updateTimestamp() {
      const now = new Date();
      const dateStr = now.toLocaleDateString('en-US', { 
        month: 'short', 
        day: '2-digit', 
        year: 'numeric' 
      });
      const timeStr = now.toTimeString().split(' ')[0];
      document.getElementById('timestamp').textContent = `${dateStr} - ${timeStr} UTC`;
    }

    async function init() {
      // Initialize UI
      initializeEmptyTiles();
      updateTimestamp();
      setInterval(updateTimestamp, 1000);

      if (!url || !token) {
        console.error('Missing URL or token');
        return;
      }

      try {
        room = new LivekitClient.Room({
          adaptiveStream: true,
          dynacast: true,
        });
        
        // Event listeners
        room.on(LivekitClient.RoomEvent.ParticipantConnected, handleParticipantConnected);
        room.on(LivekitClient.RoomEvent.ParticipantDisconnected, handleParticipantDisconnected);
        room.on(LivekitClient.RoomEvent.TrackSubscribed, handleTrackSubscribed);
        room.on(LivekitClient.RoomEvent.TrackUnsubscribed, handleTrackUnsubscribed);
        room.on(LivekitClient.RoomEvent.ActiveSpeakersChanged, handleActiveSpeakersChanged);
        room.on(LivekitClient.RoomEvent.Connected, () => {
          console.log('Room connected successfully');
          updateRoomInfo();
        });

        await room.connect(url, token);
        
        console.log('Connected to room:', room.name);
        console.log('Local participant:', room.localParticipant.identity);
        console.log('Remote participants:', Array.from(room.remoteParticipants.keys()));

        // Handle local participant
        handleParticipantConnected(room.localParticipant);
        
        // Handle existing remote participants
        room.remoteParticipants.forEach(participant => {
          handleParticipantConnected(participant);
        });

        // Set initial active speaker
        if (!activeSpeakerParticipant && room.localParticipant) {
          setActiveSpeaker(room.localParticipant);
        }

      } catch (error) {
        console.error('Failed to connect:', error);
      }
    }

    function updateRoomInfo() {
      document.getElementById('room-name').textContent = room.name || "Alex's Editing Room";
      
      const metadata = room.metadata ? JSON.parse(room.metadata) : {};
      if (metadata.roomId || metadata.teamId || metadata.sessionId) {
        document.getElementById('room-ids').textContent = 
          `${metadata.roomId || 'Room ID'} - ${metadata.teamId || 'Team ID'} - ${metadata.sessionId || 'Session ID'}`;
      }
    }

    function getNextAvailableTile() {
      for (let i = 0; i < MAX_PARTICIPANT_TILES; i++) {
        const tile = document.getElementById(`tile-${i}`);
        if (tile && tile.classList.contains('empty')) {
          return tile;
        }
      }
      return null;
    }

    function handleParticipantConnected(participant) {
      console.log('Participant connected:', participant.identity);
      
      const tile = getNextAvailableTile();
      if (!tile) {
        console.warn('No available tiles for participant:', participant.identity);
        return;
      }

      // Mark tile as occupied
      tile.classList.remove('empty');
      tile.id = `participant-${participant.identity}`;
      
      // Add name label
      const nameLabel = document.createElement('div');
      nameLabel.className = 'participant-name';
      nameLabel.textContent = participant.identity;
      tile.appendChild(nameLabel);
      
      participantElements.set(participant.identity, tile);

      // Attach existing tracks
      participant.videoTracks.forEach(publication => {
        if (publication.isSubscribed && publication.track) {
          attachVideoTrack(publication.track, participant);
        }
      });

      participant.audioTracks.forEach(publication => {
        if (publication.isSubscribed && publication.track) {
          attachAudioTrack(publication.track, participant);
        }
      });
    }

    function handleParticipantDisconnected(participant) {
      console.log('Participant disconnected:', participant.identity);
      
      const tile = participantElements.get(participant.identity);
      if (tile) {
        // Clear tile content
        tile.innerHTML = '';
        tile.classList.add('empty');
        tile.id = `tile-${Array.from(document.querySelectorAll('.participant-tile')).indexOf(tile)}`;
        participantElements.delete(participant.identity);
      }

      // If active speaker left, switch to someone else
      if (activeSpeakerParticipant && activeSpeakerParticipant.identity === participant.identity) {
        const participants = [room.localParticipant, ...Array.from(room.remoteParticipants.values())];
        const remaining = participants.filter(p => p.identity !== participant.identity);
        if (remaining.length > 0) {
          setActiveSpeaker(remaining[0]);
        } else {
          activeSpeakerParticipant = null;
          // Clear active speaker display
          const container = document.getElementById('active-speaker-container');
          const existingVideo = container.querySelector('video');
          if (existingVideo) existingVideo.remove();
        }
      }
    }

    function handleTrackSubscribed(track, publication, participant) {
      console.log('Track subscribed:', track.kind, participant.identity);
      
      if (track.kind === 'video') {
        attachVideoTrack(track, participant);
      } else if (track.kind === 'audio') {
        attachAudioTrack(track, participant);
      }
    }

    function handleTrackUnsubscribed(track, publication, participant) {
      console.log('Track unsubscribed:', track.kind, participant.identity);
      
      if (track.kind === 'video') {
        const elements = track.detach();
        elements.forEach(el => el.remove());
      }
    }

    function attachVideoTrack(track, participant) {
      const videoElement = track.attach();
      videoElement.style.width = '100%';
      videoElement.style.height = '100%';
      videoElement.style.objectFit = 'cover';

      // Add to participant tile
      const tile = participantElements.get(participant.identity);
      if (tile) {
        const existingVideo = tile.querySelector('video');
        if (existingVideo) existingVideo.remove();
        
        const nameLabel = tile.querySelector('.participant-name');
        tile.insertBefore(videoElement, nameLabel);
      }

      // Update active speaker view if this is the active speaker
      if (activeSpeakerParticipant && activeSpeakerParticipant.identity === participant.identity) {
        updateActiveSpeakerView(participant);
      }

      // Update main video player if this is the first participant
      updateMainVideoPlayer();
    }

    function attachAudioTrack(track, participant) {
      const audioElement = track.attach();
      document.body.appendChild(audioElement);
    }

    function handleActiveSpeakersChanged(speakers) {
      console.log('Active speakers changed:', speakers.map(s => s.identity));
      
      if (speakers.length > 0) {
        setActiveSpeaker(speakers[0]);
      }
    }

    function setActiveSpeaker(participant) {
      if (!participant) return;
      
      console.log('Setting active speaker:', participant.identity);
      activeSpeakerParticipant = participant;
      updateActiveSpeakerView(participant);
      updateMainVideoPlayer();
    }

    function updateActiveSpeakerView(participant) {
      // Active speaker box doesn't show video, just the title
      // Keep it as is per your design
    }

    function updateMainVideoPlayer() {
      const videoPlayer = document.getElementById('video-player');
      const placeholder = document.getElementById('video-placeholder');
      
      // Remove existing video
      const existingVideo = videoPlayer.querySelector('video');
      if (existingVideo) existingVideo.remove();

      // Find the active speaker or any participant with video
      let participantToShow = activeSpeakerParticipant;
      
      if (!participantToShow) {
        // Get first available participant
        const allParticipants = [room?.localParticipant, ...Array.from(room?.remoteParticipants?.values() || [])].filter(Boolean);
        participantToShow = allParticipants[0];
      }

      if (participantToShow) {
        let videoTrack = null;
        participantToShow.videoTracks.forEach(publication => {
          if (publication.isSubscribed && publication.track) {
            videoTrack = publication.track;
          }
        });

        if (videoTrack) {
          const videoElement = videoTrack.attach();
          videoElement.style.width = '100%';
          videoElement.style.height = '100%';
          videoElement.style.objectFit = 'cover';
          
          placeholder.style.display = 'none';
          videoPlayer.appendChild(videoElement);
        } else {
          placeholder.style.display = 'block';
        }
      } else {
        placeholder.style.display = 'block';
      }
    }

    // Initialize
    window.addEventListener('load', () => {
      console.log('Window loaded, initializing...');
      init();
    });

    if (document.readyState === 'complete') {
      init();
    }
  </script>
</body>
</html>
